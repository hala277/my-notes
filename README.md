# my-notes

## about me: 
*my name is hala almasharfeh I'm 21 years old from Amman, Jordan.I'm currently a software engineering student that will be graduate from ASAC, I have an interest in programming and web development.*


## *good-developer-mindset:ðŸ§ *

*if I want to cultivate the mindset, This mentality will aid me in making better programming decisions on a daily basis. To accomplish this, the article discusses key points that every developer should know.*

**1. Conceiving The Purpose of Software:**

*First ,comprehend the software's purpose.Developers that are unable to comprehend the project's purpose will produce poor software. and When making software decisions, I should bear the following in mind: **How can I help?***

**2. The Goals of Software Design**

*To construct and maintain systems that are as simple as feasible for developers to create and maintain, so that they can be and continue to be as helpful as possible. That is to say, the design should be simple for me and beneficial to others.*

**3. (Mis)understanding**

*The key distinction between a terrible developer and a good developer is understanding. Good developers know what they're doing, while bad developers don't.*

**4. Simplicity**

*Intelligence has nothing to do with complexity; it has everything to do with simplicity. that means I don't have to be so complex to show others that I'm smart in the end it's all about clean and understandable code.*

**5. Complexity**

*My primary goal as a developer is to manage complexity rather than to generate it. As a result, the first behavior should be an aversion to (unnecessary) change. This will keep me from including extra code in my product. When I'm certain that this change is necessary, I'll put it into action.*

**6. Maintenance**

*The two key criteria that influence code maintenance are simplicity and complexity. Any piece of software's ease of maintenance is proportional to the simplicity of its separate components. The maintenance effort is proportional to the software's complexity.*

**7. Consistency**

*Code that is inconsistent gets more difficult to understand.*

**8. Prioritizing**

*When it comes to priority, the improvements that will provide me with a lot of value while requiring little effort are preferable to those that would provide me with little value while requiring a lot of effort.*

**9. Solving Problems**

*Understand exactly what is being asked. Most difficult tasks are difficult because you do not comprehend them. Make a list of your problems and try to communicate them to someone else. Make a plan, but don't act on it. Give it some thought. Allow your brain to examine the situation and digest the facts, but don't spend too much time planning. The final stage is to break the problem into smaller jobs. Don't try to solve all of your problems at once. When you look at the problem as its whole, it can be frightening. Divide it into smaller jobs and work through each sub-problem one at a time. You connect the dots once you've solved each sub-problem.*

**10. Good enough is fine**

1. Construct a system that solely performs addition and nothing else.
2. Put it into action.
3. Improve the design of the present system so that you may add additional operations.
4. Repeat steps 2 and 3 for subtraction.
5. Repeat steps 2 and 3 for multiplication.
6. Decide on a division strategy and repeat steps 2 and 3.


**11. Predictions**

*Being too generic necessitates a lot of code that isn't required. Because you can't forecast the future, no matter how generic your solution is, it won't be generic enough to meet your actual future requirements. Most likely, this time will never come, and the code you built to answer future problems will raise complexity, make it difficult to alter the code, and finally become a burden that may damage your product. Don't make predictions about the future. Only be as generic as you know you need to be at this time.*

**12. Assumptions**

*Code should be written based on what you know right now, not what you believe will happen in the future.*

**13. Stop Reinventing**

*Don't try to reinvent the wheel.*

**14. Resistance**

*Always avoid adding more code or features until you are satisfied that they are necessary and that they must be implemented. Because unneeded changes will lead to a rise in software problems.*

**15. Automation**

*Don't waste your time on monotonous chores. Set them up and then leave them alone. They have the ability to work when you are sleeping. and if it is possible to automate it, automate it.*

**16. Code measurement**

*The best code is a relatively small amount of code that is simple to understand and read.*

**17. Productivity**

*The primary goal should be to keep your code base as small as possible. "How can I write more code?" is not the question. rather than "How can I delete more code?"*

**18. Testing**

*Logging should be added at an early stage. This will allow you to quickly identify the issue and save you time. then When you discover a bug, you must first duplicate it. You should not guess the source of a bug and then apply fixes based on your assumptions. You will almost certainly be incorrect. Before you apply the patch, you should be able to see it with your own eyes.*

**19. (Under)Estimation**

*Break the big thing down into smaller pieces. The smaller it is, the more easily it may be estimated.*

**20. Running Away From Rewriting**

*In most circumstances, rewriting code is a developer hallucination, not a solution. As a result, refactoring should be the primary option.*

**21. Documentation and Commenting**

*Another consideration is documentation. It is critical to have documentation that explains the architecture of your product as well as each module and component. This is essential in order to see a high-level view of your software.*

**22. Picking Technologies (Tools, Libraries, etc.)**

*Don't rely on third-party technologies. However, if you must rely on them, strive to decrease your reliance on them as much as possible.*

**23. Self-Development**

*Continue to learn. Experiment with various programming languages and tools, and read books on software development. They will provide you with a different perspective. Small gains every day will make a significant difference in your knowledge and skills.*

**24. Donâ€™t be a hero**

*Don't be an obsessive person. Understand when to give up. Don't be afraid to seek for assistance.*

**25. Donâ€™t Ask Questionsâ€¦ Ask For Help**

*When you can't come up with something on your own, go looking! Find solutions and put them to the test. Modify the responses, see if you can figure out why they work, and apply them to your code. Then, if necessary, you can always seek advice.*


-------------------------------
### reference
+ [Learn the fundamentals of a good developer mindset in 15 minutes](https://www.freecodecamp.org/news/learn-the-fundamentals-of-a-good-developer-mindset-in-15-minutes-81321ab8a682/) 

